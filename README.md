What was the problem you were solving in the projects for this course?
- The problem that this software addresses is for an end-user to be able to upload university course data from a CSV file, following a specified schema, and be able to interact with it though CLI prompts. Specifically, users would need to be able to have the ability to load data, view a sorted list of the data, and be able to search for a specific data node.

How did you approach the problem? Consider why data structures are important to understand.
- I approached the problem by first defining an appropriate data structure to house the data that had minimal complexity and could easily be encapsulated. Key attributes that led to the choice of data structure was how functionality such as searching and sorting could be implemented in the least computationally demanding way.

How did you overcome any roadblocks you encountered while going through the activities or project?
- Common roadblocks I encountered pertained heavily to the development of the logic of the program, and it's requirements. For this, I referenced community resources and online help to ensure my development practices encompassed best practices and would meet the needs of the end-user.

How has your work on this project expanded your approach to designing software and developing programs?
- Work on this project has deepened my attention to runtime complexities of programs, as well as management of memory addresses. More often than not, programs are built to perform calculations, though the simplest solution is not always the most optimal. Prior to this, much of my code would make use of defensive copies and duplicates for simple comparison operations and the like. Now I am more aware of when object copies and references are needed and appropriate

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
- I did my best to focus on encapsulation and secure memory management in this project. I wanted to build methods as individual components that operated on a principle of single-functionality. So that if ever any individual method needed to be revised, it would not directly impact the function of any other method or the program as a whole. This, however, requires a lot of redendant value checking and error handling. As for memory management, when working in more base-level languages such as C++, I pay more critical attention to when objects are instantiated, referenced, or copied.
